---
alwaysApply: true
---
Project Standards (Folder Structure, Types, State, Hooks, Services, Components, Suspense)

Technology baseline
- Use Next.js 16 (App Router, Server Components, Server Actions). Prefer route-level `loading.tsx`/`error.tsx`, cache-aware data fetching, and `Suspense` per guidance below. See `https://nextjs.org/blog/next-16`.
- Use Tailwind CSS v4. Simplified setup with `@import "tailwindcss"`, automatic content detection, and modern CSS features. See `https://tailwindcss.com/blog/tailwindcss-v4`.
- Use Zod for schema validation and React Hook Form for form handling. Always use `@hookform/resolvers` to integrate Zod with RHF.
- Use TanStack Query for server state management (API data, caching, refetching).
- **CRITICAL**: Never use `any` type. Always define proper types or use `unknown` with type guards.

Folder structure (per feature)
- Place features under `apps/web/src/features/<featureName>/`:
  - `types/` — only type declarations. Prefer `index.d.ts` or topic-based `*.d.ts`.
  - `schemas/` — Zod schemas for validation. One schema file per form/validation concern (e.g., `login.schema.ts`, `user.schema.ts`).
  - `stores/` — Zustand state. One store per domain, named `use<Domain>Store.ts`.
  - `hooks/` — feature-scoped React hooks, named `use<Thing>.ts`. Use hooks to encapsulate business logic, NOT in components.
  - `services/` — API/side-effects. One module per remote domain.
  - `components/` — UI components. Keep small, focused, and reusable.
    - **CRITICAL**: Never mix business logic with UI components. Components should only handle presentation and user interaction.
    - Use hooks to extract business logic from components.
    - Example: `login-form.tsx` should use `useLogin` hook, not directly call store/service.

Types
- Use `.d.ts` for ambient/shared declarations inside `types/`.
- Export DTOs and domain types from `types/` and import everywhere else.
- Never import React or runtime code inside `.d.ts` files.

Schemas (`schemas/`)
- File name: `<feature>.schema.ts` (e.g., `login.schema.ts`, `user.schema.ts`).
- Export Zod schema and inferred TypeScript type: `export const loginSchema = z.object({...})` and `export type LoginFormData = z.infer<typeof loginSchema>`.
- Keep schemas focused on single validation concern.
- Use for both client-side (React Hook Form) and can be shared with backend validation.

Zustand stores (`stores/`)
- File name: `use<Domain>Store.ts`. Export the hook as default or named.
- Keep state minimal: persist only necessary primitives/ids; derive the rest in selectors.
- Use slices for complex domains; colocate actions with their slice.
- If persistence is required, isolate it (e.g., middleware) and document keys.
- **CRITICAL**: Stores should NOT contain business logic. They only manage state. Business logic goes in hooks or services.

Hooks (`hooks/`)
- Prefix with `use`. One responsibility per hook. SSR-safe by default.
- **CRITICAL**: Extract business logic from components into hooks.
- Example: `useLogin` hook should handle form submission, error handling, navigation - NOT in component.
- Do not reach into stores from hooks unless the hook's purpose is state access.
- Side-effects live in hooks; UI logic (presentation, styling) lives in components.
- Hooks can call services and update stores, but components should call hooks, not services/stores directly.

Services (`services/`)
- Isolate all network calls. No UI/state code.
- Return typed results (DTOs → map to domain types as needed).
- Centralize endpoints/constants. Handle errors close to the edge; throw typed errors.
- Services should match API response format (with `success`, `data`, `error` wrapper).

Components (`components/`)
- **CRITICAL**: Components must be separated by concern:
  - **UI Components** (`ui/`): Pure presentation, no business logic, no state management.
  - **Container Components**: Wire hooks/stores to UI, but logic should be in hooks.
  - **Feature Components**: Combine UI + containers, but delegate logic to hooks.
- Prefer controlled, stateless components. Accept props; avoid hidden state.
- **NEVER** put business logic directly in components. Always extract to hooks.
- Example separation:
  - `login-form.tsx` (UI) → `useLogin` hook (logic) → `authService` (API) → `useAuthStore` (state)
- Keep feature components inside the feature; only promote to `shared/` when reused broadly.

Smart Suspense usage (Next.js App Router)
- Prioritize static/above-the-fold UI:
  - Use route-level `loading.tsx` for coarse skeletons.
  - Wrap only truly async subtrees in `Suspense` with lightweight fallbacks.
- Prefer multiple small Suspense boundaries over one large boundary.
- Do not suspend global layout chrome; suspend leaf/async components instead.
- For lists, show static shell (headers, filters) immediately; suspend the data region.
- Combine with `error.tsx` for graceful failures; never block the entire page for one widget.

Backend Standards (Go + Gin)
- Use layered architecture: Handler → Service → Repository.
- Use dependency injection pattern (constructor-based).
- Use interface-based design for repositories.
- Follow API response standards from `/docs/api-standart/`.
- All errors must use error codes from `/docs/api-standart/api-error-codes.md`.
- **CRITICAL**: When adding/modifying backend endpoints:
  1. Update Postman collection: `/docs/postman/CRM-Healthcare-API.postman_collection.json`
  2. Update Postman documentation if needed: `/docs/postman/README.md` or `/docs/postman/SETUP.md`
  3. Test with Postman before marking as complete.

Sprint Management
- **CRITICAL**: When completing sprint tasks:
  1. Mark completed tasks in `/docs/SPRINT_PLANNING.md` with `[x]`
  2. Update acceptance criteria status if applicable
  3. Document any deviations or additional work done
- Do NOT create separate completion documents. Update `SPRINT_PLANNING.md` directly.

Naming & conventions
- Kebab-case directories, PascalCase components, camelCase functions/variables.
- Each folder can have an `index.ts` barrel only when it improves DX and tree-shaking.
- Keep files short and cohesive; extract when a file grows beyond one responsibility.

Component Logic Separation Examples

❌ BAD - Logic in component:
```tsx
export function LoginForm() {
  const [email, setEmail] = useState("");
  const [password, setPassword] = useState("");
  
  const handleSubmit = async () => {
    // Business logic in component - BAD!
    const response = await authService.login({ email, password });
    if (response.success) {
      useAuthStore.getState().setUser(response.data.user);
      router.push("/dashboard");
    }
  };
  
  return <form onSubmit={handleSubmit}>...</form>;
}
```

✅ GOOD - Logic in hook:
```tsx
// hooks/useLogin.ts
export function useLogin() {
  const router = useRouter();
  const { login } = useAuthStore();
  
  return useMutation({
    mutationFn: (data: LoginFormData) => login(data.email, data.password),
    onSuccess: () => router.push("/dashboard"),
  });
}

// components/login-form.tsx
export function LoginForm() {
  const { register, handleSubmit, formState: { errors } } = useForm<LoginFormData>({
    resolver: zodResolver(loginSchema),
  });
  const { mutate: login, isPending } = useLogin();
  
  return <form onSubmit={handleSubmit((data) => login(data))}>...</form>;
}
```
